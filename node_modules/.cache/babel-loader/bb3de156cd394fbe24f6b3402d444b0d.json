{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useRoutes = exports.getWorkingPath = exports.usePath = exports.getPath = exports.setPath = exports.navigate = exports.ParentContext = exports.getBasepath = exports.setBasepath = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _isNode = _interopRequireDefault(require(\"./isNode\"));\n\nvar _queryParams = require(\"./queryParams\");\n\nvar _interceptor = require(\"./interceptor\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar preparedRoutes = {};\nvar stack = {};\nvar componentId = 1;\nvar currentPath = _isNode.default ? '' : location.pathname;\nvar basePath = '';\nvar basePathRegEx = null;\nvar pathUpdaters = [];\n/**\r\n * Will define a base path that will be utilized in your routing and navigation.\r\n * To be called _before_ any routing or navigation happens.\r\n * @param {string} inBasepath\r\n */\n\nvar setBasepath = function setBasepath(inBasepath) {\n  basePath = inBasepath;\n  basePathRegEx = new RegExp('^' + basePath);\n};\n/**\r\n * Returns the currently used base path.\r\n * @returns {string}\r\n */\n\n\nexports.setBasepath = setBasepath;\n\nvar getBasepath = function getBasepath() {\n  return basePath;\n};\n\nexports.getBasepath = getBasepath;\n\nvar resolvePath = function resolvePath(inPath) {\n  if (_isNode.default) {\n    var url = require('url');\n\n    return url.resolve(currentPath, inPath);\n  }\n\n  var current = new URL(currentPath, location.href);\n  var resolved = new URL(inPath, current);\n  return resolved.pathname;\n};\n\nvar ParentContext = _react.default.createContext(null);\n/**\r\n * Pass a route string to this function to receive a regular expression.\r\n * The transformation will be cached and if you pass the same route a second\r\n * time, the cached regex will be returned.\r\n * @param {string} inRoute\r\n * @returns {Array} [RegExp, propList]\r\n */\n\n\nexports.ParentContext = ParentContext;\n\nvar prepareRoute = function prepareRoute(inRoute) {\n  if (preparedRoutes[inRoute]) {\n    return preparedRoutes[inRoute];\n  }\n\n  var preparedRoute = [new RegExp(\"\".concat(inRoute.substr(0, 1) === '*' ? '' : '^').concat(inRoute.replace(/:[a-zA-Z]+/g, '([^/]+)').replace(/\\*/g, '')).concat(inRoute.substr(-1) === '*' ? '' : '$'))];\n  var propList = inRoute.match(/:[a-zA-Z]+/g);\n  preparedRoute.push(propList ? propList.map(function (paramName) {\n    return paramName.substr(1);\n  }) : []);\n  preparedRoutes[inRoute] = preparedRoute;\n  return preparedRoute;\n};\n/**\r\n * Virtually navigates the browser to the given URL and re-processes all routers.\r\n * @param {string} url The URL to navigate to. Do not mix adding GET params here and using the `getParams` argument.\r\n * @param {boolean} [replace=false] Should the navigation be done with a history replace to prevent back navigation by the user\r\n * @param {object} [queryParams] Key/Value pairs to convert into get parameters to be appended to the URL.\r\n * @param {boolean} [replaceQueryParams=true] Should existing query parameters be carried over, or dropped (replaced)?\r\n */\n\n\nvar navigate = function navigate(url) {\n  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var replaceQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  url = (0, _interceptor.interceptRoute)(currentPath, resolvePath(url));\n\n  if (!url || url === currentPath) {\n    return;\n  }\n\n  currentPath = url;\n\n  if (_isNode.default) {\n    setPath(url);\n    processStack();\n    updatePathHooks();\n    return;\n  }\n\n  var finalURL = basePathRegEx ? url.match(basePathRegEx) ? url : basePath + url : url;\n  window.history[\"\".concat(replace ? 'replace' : 'push', \"State\")](null, null, finalURL);\n  processStack();\n  updatePathHooks();\n\n  if (queryParams) {\n    (0, _queryParams.setQueryParams)(queryParams, replaceQueryParams);\n  }\n};\n\nexports.navigate = navigate;\nvar customPath = '/';\n/**\r\n * Enables you to manually set the path from outside in a nodeJS environment, where window.history is not available.\r\n * @param {string} inPath\r\n */\n\nvar setPath = function setPath(inPath) {\n  var url = require('url');\n\n  customPath = url.resolve(customPath, inPath);\n};\n/**\r\n * Returns the current path of the router.\r\n * @returns {string}\r\n */\n\n\nexports.setPath = setPath;\n\nvar getPath = function getPath() {\n  return customPath;\n};\n/**\r\n * This hook returns the currently used URI.\r\n * Works in a browser context as well as for SSR.\r\n *\r\n * _Heads up:_ This will make your component render on every navigation unless you set this hook to passive!\r\n * @param {boolean} [active=true] Will update the component upon path changes. Set to false to only retrieve the path, once.\r\n * @param {boolean} [withBasepath=false] Should the base path be left at the beginning of the URI?\r\n * @returns {string}\r\n */\n\n\nexports.getPath = getPath;\n\nvar usePath = function usePath() {\n  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var withBasepath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var _React$useState = _react.default.useState(0),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      setUpdate = _React$useState2[1];\n\n  _react.default.useEffect(function () {\n    if (!active) {\n      return;\n    }\n\n    pathUpdaters.push(setUpdate);\n    return function () {\n      var index = pathUpdaters.indexOf(setUpdate);\n\n      if (index !== -1) {\n        pathUpdaters.splice(index, 1);\n      }\n    };\n  }, [setUpdate]);\n\n  return withBasepath ? currentPath : currentPath.replace(basePathRegEx, '');\n};\n/**\r\n * Render all components that use path hooks.\r\n */\n\n\nexports.usePath = usePath;\n\nvar updatePathHooks = function updatePathHooks() {\n  var now = Date.now();\n  pathUpdaters.forEach(function (cb) {\n    return cb(now);\n  });\n};\n/**\r\n * Called from within the router. This returns either the current windows url path\r\n * or a already reduced path, if a parent router has already matched with a finishing\r\n * wildcard before.\r\n * @param {string} [parentRouterId]\r\n * @returns {string}\r\n */\n\n\nvar getWorkingPath = function getWorkingPath(parentRouterId) {\n  if (!parentRouterId) {\n    return _isNode.default ? customPath : window.location.pathname.replace(basePathRegEx, '') || '/';\n  }\n\n  var stackEntry = stack[parentRouterId];\n\n  if (!stackEntry) {\n    throw 'wth';\n  }\n\n  return stackEntry.reducedPath !== null ? stackEntry.reducedPath || '/' : window.location.pathname;\n};\n\nexports.getWorkingPath = getWorkingPath;\n\nvar processStack = function processStack() {\n  return Object.values(stack).forEach(process);\n};\n/**\r\n * This function takes two objects and compares if they have the same\r\n * keys and their keys have the same values assigned, so the objects are\r\n * basically the same.\r\n * @param {object} objA\r\n * @param {object} objB\r\n * @return {boolean}\r\n */\n\n\nvar objectsEqual = function objectsEqual(objA, objB) {\n  var objAKeys = Object.keys(objA);\n  var objBKeys = Object.keys(objB);\n\n  var valueIsEqual = function valueIsEqual(key) {\n    return objB.hasOwnProperty(key) && objA[key] === objB[key];\n  };\n\n  return objAKeys.length === objBKeys.length && objAKeys.every(valueIsEqual);\n};\n\nif (!_isNode.default) {\n  window.addEventListener('popstate', function (e) {\n    var nextPath = (0, _interceptor.interceptRoute)(currentPath, location.pathname);\n\n    if (!nextPath || nextPath === currentPath) {\n      e.preventDefault();\n      e.stopPropagation();\n      history.pushState(null, null, currentPath);\n      return;\n    }\n\n    currentPath = nextPath;\n\n    if (nextPath !== location.pathname) {\n      history.replaceState(null, null, nextPath);\n    }\n\n    processStack();\n    updatePathHooks();\n  });\n}\n\nvar emptyFunc = function emptyFunc() {\n  return null;\n};\n/**\r\n * This will calculate the match of a given router.\r\n * @param {object} stackObj\r\n * @param {boolean} [directCall] If its not a direct call, the process function might trigger a component render.\r\n */\n\n\nvar process = function process(stackObj, directCall) {\n  var routerId = stackObj.routerId,\n      parentRouterId = stackObj.parentRouterId,\n      routes = stackObj.routes,\n      setUpdate = stackObj.setUpdate,\n      resultFunc = stackObj.resultFunc,\n      resultProps = stackObj.resultProps,\n      previousReducedPath = stackObj.reducedPath;\n  var currentPath = getWorkingPath(parentRouterId);\n  var route = null;\n  var targetFunction = null;\n  var targetProps = null;\n  var reducedPath = null;\n  var anyMatched = false;\n\n  for (var i = 0; i < routes.length; i++) {\n    var _routes$i = _slicedToArray(routes[i], 2);\n\n    route = _routes$i[0];\n    targetFunction = _routes$i[1];\n\n    var _ref = preparedRoutes[route] ? preparedRoutes[route] : prepareRoute(route),\n        _ref2 = _slicedToArray(_ref, 2),\n        regex = _ref2[0],\n        groupNames = _ref2[1];\n\n    var _result = currentPath.match(regex);\n\n    if (!_result) {\n      targetFunction = emptyFunc;\n      continue;\n    }\n\n    if (groupNames.length) {\n      targetProps = {};\n\n      for (var j = 0; j < groupNames.length; j++) {\n        targetProps[groupNames[j]] = _result[j + 1];\n      }\n    }\n\n    reducedPath = currentPath.replace(_result[0], '');\n    anyMatched = true;\n    break;\n  }\n\n  if (!stack[routerId]) {\n    return;\n  }\n\n  if (!anyMatched) {\n    route = null;\n    targetFunction = null;\n    targetProps = null;\n    reducedPath = null;\n  }\n\n  var funcsDiffer = resultFunc !== targetFunction;\n  var pathDiffer = reducedPath !== previousReducedPath;\n  var propsDiffer = true;\n\n  if (!funcsDiffer) {\n    if (!resultProps && !targetProps) {\n      propsDiffer = false;\n    } else {\n      propsDiffer = !(resultProps && targetProps && objectsEqual(resultProps, targetProps) === true);\n    }\n\n    if (!propsDiffer) {\n      if (!pathDiffer) {\n        return;\n      }\n    }\n  }\n\n  var result = funcsDiffer || propsDiffer ? targetFunction ? targetFunction(targetProps) : null : stackObj.result;\n  Object.assign(stack[routerId], {\n    result: result,\n    reducedPath: reducedPath,\n    matchedRoute: route,\n    passContext: route ? route.substr(-1) === '*' : false\n  });\n\n  if (!directCall && (funcsDiffer || propsDiffer || route === null)) {\n    setUpdate(Date.now());\n  }\n};\n/**\r\n * If a route returns a function, instead of a react element, we need to wrap this function\r\n * to eventually wrap a context object around its result.\r\n * @param RouteContext\r\n * @param originalResult\r\n * @returns {function(): *}\r\n */\n\n\nvar wrapperFunction = function wrapperFunction(RouteContext, originalResult) {\n  return function () {\n    return _react.default.createElement(RouteContext, null, originalResult.apply(originalResult, arguments));\n  };\n};\n/**\r\n * Pass an object to this function where the keys are routes and the values\r\n * are functions to be executed when a route matches. Whatever your function returns\r\n * will be returned from the hook as well into your react component. Ideally you would\r\n * return components to be rendered when certain routes match, but you are not limited\r\n * to that.\r\n * @param {object} routeObj {\"/someRoute\": () => <Example />}\r\n */\n\n\nvar useRoutes = function useRoutes(routeObj) {\n  // Each router gets an internal id to look them up again.\n  var _React$useState3 = _react.default.useState(componentId),\n      _React$useState4 = _slicedToArray(_React$useState3, 1),\n      routerId = _React$useState4[0];\n\n  var setUpdate = _react.default.useState(0)[1]; // Needed to create nested routers which use only a subset of the URL.\n\n\n  var parentRouterId = _react.default.useContext(ParentContext); // If we just took the last ID, increase it for the next hook.\n\n\n  if (routerId === componentId) {\n    componentId += 1;\n  } // Removes the router from the stack after component unmount - it won't be processed anymore.\n\n\n  _react.default.useEffect(function () {\n    return function () {\n      return delete stack[routerId];\n    };\n  }, [routerId]);\n\n  var stackObj = stack[routerId];\n\n  if (stackObj && stackObj.originalRouteObj !== routeObj) {\n    stackObj = null;\n  }\n\n  if (!stackObj) {\n    stackObj = {\n      routerId: routerId,\n      originalRouteObj: routeObj,\n      routes: Object.entries(routeObj),\n      setUpdate: setUpdate,\n      parentRouterId: parentRouterId,\n      matchedRoute: null,\n      reducedPath: null,\n      passContext: false,\n      result: null\n    };\n    stack[routerId] = stackObj;\n    process(stackObj, true);\n  }\n\n  _react.default.useDebugValue(stackObj.matchedRoute);\n\n  if (!stackObj.matchedRoute) {\n    return null;\n  }\n\n  var result = stackObj.result;\n\n  if (!stackObj.passContext) {\n    return result;\n  } else {\n    var RouteContext = function RouteContext(_ref3) {\n      var children = _ref3.children;\n      return _react.default.createElement(ParentContext.Provider, {\n        value: routerId\n      }, children);\n    };\n\n    if (typeof result === 'function') {\n      return wrapperFunction(RouteContext, result);\n    }\n\n    return _react.default.isValidElement(result) && result.type !== RouteContext ? _react.default.createElement(RouteContext, null, result) : result;\n  }\n};\n\nexports.useRoutes = useRoutes;","map":{"version":3,"sources":["../src/router.js"],"names":["preparedRoutes","stack","componentId","currentPath","isNode","location","basePath","basePathRegEx","pathUpdaters","setBasepath","getBasepath","resolvePath","url","require","current","resolved","ParentContext","React","prepareRoute","preparedRoute","inRoute","propList","paramName","navigate","replace","queryParams","replaceQueryParams","setPath","processStack","updatePathHooks","finalURL","window","customPath","getPath","usePath","active","withBasepath","setUpdate","index","now","Date","cb","getWorkingPath","stackEntry","Object","objectsEqual","objAKeys","objBKeys","valueIsEqual","objB","objA","nextPath","e","history","emptyFunc","process","routerId","parentRouterId","routes","resultFunc","resultProps","previousReducedPath","stackObj","route","targetFunction","targetProps","reducedPath","anyMatched","i","regex","groupNames","result","j","funcsDiffer","pathDiffer","propsDiffer","matchedRoute","passContext","wrapperFunction","originalResult","useRoutes","originalRouteObj","RouteContext","children"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport isNode from './isNode';\r\nimport {setQueryParams} from './queryParams';\r\nimport {interceptRoute} from './interceptor';\r\n\r\nlet preparedRoutes = {};\r\nlet stack = {};\r\nlet componentId = 1;\r\nlet currentPath = isNode ? '' : location.pathname;\r\nlet basePath = '';\r\nlet basePathRegEx = null;\r\nconst pathUpdaters = [];\r\n\r\n/**\r\n * Will define a base path that will be utilized in your routing and navigation.\r\n * To be called _before_ any routing or navigation happens.\r\n * @param {string} inBasepath\r\n */\r\nexport const setBasepath = (inBasepath) => {\r\n\tbasePath = inBasepath;\r\n\tbasePathRegEx = new RegExp('^' + basePath);\r\n};\r\n\r\n/**\r\n * Returns the currently used base path.\r\n * @returns {string}\r\n */\r\nexport const getBasepath = () => basePath;\r\n\r\nconst resolvePath = (inPath) => {\r\n\tif (isNode) {\r\n\t\tconst url = require('url');\r\n\t\treturn url.resolve(currentPath, inPath);\r\n\t}\r\n\r\n\tconst current = new URL(currentPath, location.href);\r\n\tconst resolved = new URL(inPath, current);\r\n\treturn resolved.pathname;\r\n};\r\n\r\nexport const ParentContext = React.createContext(null);\r\n\r\n/**\r\n * Pass a route string to this function to receive a regular expression.\r\n * The transformation will be cached and if you pass the same route a second\r\n * time, the cached regex will be returned.\r\n * @param {string} inRoute\r\n * @returns {Array} [RegExp, propList]\r\n */\r\nconst prepareRoute = (inRoute) => {\r\n\tif (preparedRoutes[inRoute]) {\r\n\t\treturn preparedRoutes[inRoute];\r\n\t}\r\n\r\n\tconst preparedRoute = [\r\n\t\tnew RegExp(`${inRoute.substr(0, 1) === '*' ? '' : '^'}${inRoute.replace(/:[a-zA-Z]+/g, '([^/]+)').replace(/\\*/g, '')}${inRoute.substr(-1,) === '*' ? '' : '$'}`)\r\n\t];\r\n\r\n\tconst propList = inRoute.match(/:[a-zA-Z]+/g);\r\n\tpreparedRoute.push(\r\n\t\tpropList\r\n\t\t\t? propList.map(paramName => paramName.substr(1))\r\n\t\t\t: []\r\n\t);\r\n\r\n\tpreparedRoutes[inRoute] = preparedRoute;\r\n\treturn preparedRoute;\r\n};\r\n\r\n/**\r\n * Virtually navigates the browser to the given URL and re-processes all routers.\r\n * @param {string} url The URL to navigate to. Do not mix adding GET params here and using the `getParams` argument.\r\n * @param {boolean} [replace=false] Should the navigation be done with a history replace to prevent back navigation by the user\r\n * @param {object} [queryParams] Key/Value pairs to convert into get parameters to be appended to the URL.\r\n * @param {boolean} [replaceQueryParams=true] Should existing query parameters be carried over, or dropped (replaced)?\r\n */\r\nexport const navigate = (url, replace = false, queryParams = null, replaceQueryParams = true) => {\r\n\turl = interceptRoute(currentPath, resolvePath(url));\r\n\r\n\tif (!url || url === currentPath) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tcurrentPath = url;\r\n\r\n\tif (isNode) {\r\n\t\tsetPath(url);\r\n\t\tprocessStack();\r\n\t\tupdatePathHooks();\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst finalURL = basePathRegEx\r\n\t\t? url.match(basePathRegEx)\r\n\t\t\t? url\r\n\t\t\t: basePath + url\r\n\t\t:\r\n\t\turl;\r\n\r\n\twindow.history[`${replace ? 'replace' : 'push'}State`](null, null, finalURL);\r\n\tprocessStack();\r\n\tupdatePathHooks();\r\n\r\n\tif (queryParams) {\r\n\t\tsetQueryParams(queryParams, replaceQueryParams);\r\n\t}\r\n};\r\n\r\nlet customPath = '/';\r\n/**\r\n * Enables you to manually set the path from outside in a nodeJS environment, where window.history is not available.\r\n * @param {string} inPath\r\n */\r\nexport const setPath = (inPath) => {\r\n\tconst url = require('url');\r\n\tcustomPath = url.resolve(customPath, inPath);\r\n};\r\n\r\n/**\r\n * Returns the current path of the router.\r\n * @returns {string}\r\n */\r\nexport const getPath = () => customPath;\r\n\r\n/**\r\n * This hook returns the currently used URI.\r\n * Works in a browser context as well as for SSR.\r\n *\r\n * _Heads up:_ This will make your component render on every navigation unless you set this hook to passive!\r\n * @param {boolean} [active=true] Will update the component upon path changes. Set to false to only retrieve the path, once.\r\n * @param {boolean} [withBasepath=false] Should the base path be left at the beginning of the URI?\r\n * @returns {string}\r\n */\r\nexport const usePath = (active = true, withBasepath = false) => {\r\n\tconst [, setUpdate] = React.useState(0);\r\n\r\n\tReact.useEffect(() => {\r\n\t\tif (!active) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tpathUpdaters.push(setUpdate);\r\n\t\treturn () => {\r\n\t\t\tconst index = pathUpdaters.indexOf(setUpdate);\r\n\t\t\tif (index !== -1) {\r\n\t\t\t\tpathUpdaters.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\t}, [setUpdate]);\r\n\r\n\treturn withBasepath ? currentPath : currentPath.replace(basePathRegEx, '');\r\n};\r\n\r\n/**\r\n * Render all components that use path hooks.\r\n */\r\nconst updatePathHooks = () => {\r\n\tconst now = Date.now();\r\n\tpathUpdaters.forEach(cb => cb(now));\r\n};\r\n\r\n/**\r\n * Called from within the router. This returns either the current windows url path\r\n * or a already reduced path, if a parent router has already matched with a finishing\r\n * wildcard before.\r\n * @param {string} [parentRouterId]\r\n * @returns {string}\r\n */\r\nexport const getWorkingPath = (parentRouterId) => {\r\n\tif (!parentRouterId) {\r\n\t\treturn isNode ? customPath : window.location.pathname.replace(basePathRegEx, '') || '/';\r\n\t}\r\n\tconst stackEntry = stack[parentRouterId];\r\n\tif (!stackEntry) {\r\n\t\tthrow 'wth';\r\n\t}\r\n\r\n\treturn stackEntry.reducedPath !== null ? stackEntry.reducedPath || '/' : window.location.pathname;\r\n};\r\n\r\nconst processStack = () => Object.values(stack).forEach(process);\r\n\r\n/**\r\n * This function takes two objects and compares if they have the same\r\n * keys and their keys have the same values assigned, so the objects are\r\n * basically the same.\r\n * @param {object} objA\r\n * @param {object} objB\r\n * @return {boolean}\r\n */\r\nconst objectsEqual = (objA, objB) => {\r\n\tconst objAKeys = Object.keys(objA);\r\n\tconst objBKeys = Object.keys(objB);\r\n\r\n\tconst valueIsEqual = key => objB.hasOwnProperty(key) && objA[key] === objB[key];\r\n\r\n\treturn (\r\n\t\tobjAKeys.length === objBKeys.length\r\n\t\t&& objAKeys.every(valueIsEqual)\r\n\t);\r\n};\r\n\r\nif (!isNode) {\r\n\twindow.addEventListener('popstate', (e) => {\r\n\t\tconst nextPath = interceptRoute(currentPath, location.pathname);\r\n\r\n\t\tif (!nextPath || nextPath === currentPath) {\r\n\t\t\te.preventDefault();\r\n\t\t\te.stopPropagation();\r\n\t\t\thistory.pushState(null, null, currentPath);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcurrentPath = nextPath;\r\n\r\n\t\tif (nextPath !== location.pathname) {\r\n\t\t\thistory.replaceState(null, null, nextPath);\r\n\t\t}\r\n\t\tprocessStack();\r\n\t\tupdatePathHooks();\r\n\t});\r\n}\r\n\r\nconst emptyFunc = () => null;\r\n\r\n/**\r\n * This will calculate the match of a given router.\r\n * @param {object} stackObj\r\n * @param {boolean} [directCall] If its not a direct call, the process function might trigger a component render.\r\n */\r\nconst process = (stackObj, directCall) => {\r\n\tconst {\r\n\t\trouterId,\r\n\t\tparentRouterId,\r\n\t\troutes,\r\n\t\tsetUpdate,\r\n\t\tresultFunc,\r\n\t\tresultProps,\r\n\t\treducedPath: previousReducedPath\r\n\t} = stackObj;\r\n\r\n\tconst currentPath = getWorkingPath(parentRouterId);\r\n\tlet route = null;\r\n\tlet targetFunction = null;\r\n\tlet targetProps = null;\r\n\tlet reducedPath = null;\r\n\tlet anyMatched = false;\r\n\r\n\tfor (let i = 0; i < routes.length; i++) {\r\n\t\t[route, targetFunction] = routes[i];\r\n\t\tconst [regex, groupNames] = preparedRoutes[route]\r\n\t\t\t? preparedRoutes[route]\r\n\t\t\t: prepareRoute(route);\r\n\r\n\t\tconst result = currentPath.match(regex);\r\n\t\tif (!result) {\r\n\t\t\ttargetFunction = emptyFunc;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (groupNames.length) {\r\n\t\t\ttargetProps = {};\r\n\t\t\tfor (let j = 0; j < groupNames.length; j++) {\r\n\t\t\t\ttargetProps[groupNames[j]] = result[j + 1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treducedPath = currentPath.replace(result[0], '');\r\n\t\tanyMatched = true;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (!stack[routerId]) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!anyMatched) {\r\n\t\troute = null;\r\n\t\ttargetFunction = null;\r\n\t\ttargetProps = null;\r\n\t\treducedPath = null;\r\n\t}\r\n\r\n\tconst funcsDiffer = resultFunc !== targetFunction;\r\n\tconst pathDiffer = reducedPath !== previousReducedPath;\r\n\tlet propsDiffer = true;\r\n\r\n\tif (!funcsDiffer) {\r\n\t\tif (!resultProps && !targetProps) {\r\n\t\t\tpropsDiffer = false;\r\n\t\t} else {\r\n\t\t\tpropsDiffer = !(resultProps && targetProps && objectsEqual(resultProps, targetProps) === true);\r\n\t\t}\r\n\r\n\t\tif (!propsDiffer) {\r\n\t\t\tif (!pathDiffer) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst result = funcsDiffer || propsDiffer\r\n\t\t? targetFunction\r\n\t\t\t? targetFunction(targetProps)\r\n\t\t\t: null\r\n\t\t: stackObj.result;\r\n\r\n\tObject.assign(stack[routerId], {\r\n\t\tresult,\r\n\t\treducedPath,\r\n\t\tmatchedRoute: route,\r\n\t\tpassContext: route ? route.substr(-1) === '*' : false\r\n\t});\r\n\r\n\tif (!directCall && (funcsDiffer || propsDiffer || route === null)) {\r\n\t\tsetUpdate(Date.now());\r\n\t}\r\n};\r\n\r\n/**\r\n * If a route returns a function, instead of a react element, we need to wrap this function\r\n * to eventually wrap a context object around its result.\r\n * @param RouteContext\r\n * @param originalResult\r\n * @returns {function(): *}\r\n */\r\nconst wrapperFunction = (RouteContext, originalResult) => function (){\r\n\treturn (\r\n\t\t<RouteContext>{originalResult.apply(originalResult, arguments)}</RouteContext>\r\n\t);\r\n};\r\n\r\n/**\r\n * Pass an object to this function where the keys are routes and the values\r\n * are functions to be executed when a route matches. Whatever your function returns\r\n * will be returned from the hook as well into your react component. Ideally you would\r\n * return components to be rendered when certain routes match, but you are not limited\r\n * to that.\r\n * @param {object} routeObj {\"/someRoute\": () => <Example />}\r\n */\r\nexport const useRoutes = (routeObj) => {\r\n\t// Each router gets an internal id to look them up again.\r\n\tconst [routerId] = React.useState(componentId);\r\n\tconst setUpdate = React.useState(0)[1];\r\n\t// Needed to create nested routers which use only a subset of the URL.\r\n\tconst parentRouterId = React.useContext(ParentContext);\r\n\r\n\t// If we just took the last ID, increase it for the next hook.\r\n\tif (routerId === componentId) {\r\n\t\tcomponentId += 1;\r\n\t}\r\n\r\n\t// Removes the router from the stack after component unmount - it won't be processed anymore.\r\n\tReact.useEffect(() => () => delete stack[routerId], [routerId]);\r\n\r\n\tlet stackObj = stack[routerId];\r\n\r\n\tif (stackObj && stackObj.originalRouteObj !== routeObj) {\r\n\t\tstackObj = null;\r\n\t}\r\n\r\n\tif (!stackObj) {\r\n\t\tstackObj = {\r\n\t\t\trouterId,\r\n\t\t\toriginalRouteObj: routeObj,\r\n\t\t\troutes: Object.entries(routeObj),\r\n\t\t\tsetUpdate,\r\n\t\t\tparentRouterId,\r\n\t\t\tmatchedRoute: null,\r\n\t\t\treducedPath: null,\r\n\t\t\tpassContext: false,\r\n\t\t\tresult: null\r\n\t\t};\r\n\r\n\t\tstack[routerId] = stackObj;\r\n\r\n\t\tprocess(stackObj, true);\r\n\t}\r\n\r\n\tReact.useDebugValue(stackObj.matchedRoute);\r\n\r\n\tif (!stackObj.matchedRoute) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet result = stackObj.result;\r\n\r\n\tif (!stackObj.passContext) {\r\n\t\treturn result;\r\n\t} else {\r\n\t\tconst RouteContext = ({children}) => <ParentContext.Provider value={routerId}>{children}</ParentContext.Provider>;\r\n\r\n\t\tif (typeof result === 'function') {\r\n\t\t\treturn wrapperFunction(RouteContext, result);\r\n\t\t}\r\n\r\n\t\treturn React.isValidElement(result) && result.type !== RouteContext\r\n\t\t\t? <RouteContext>{result}</RouteContext>\r\n\t\t\t: result;\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}