{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useControlledInterceptor = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _interceptor = require(\"./interceptor\");\n\nvar _router = require(\"./router\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\n\n\nvar useControlledInterceptor = function useControlledInterceptor() {\n  var _React$useState = _react.default.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      interceptedPath = _React$useState2[0],\n      setInterceptedPath = _React$useState2[1];\n\n  var interceptorFunction = _react.default.useMemo(function () {\n    return function (currentPath, nextPath) {\n      setInterceptedPath(nextPath);\n      return currentPath;\n    };\n  }, [setInterceptedPath]);\n\n  var stopInterception = (0, _interceptor.useInterceptor)(interceptorFunction);\n\n  var confirmNavigation = _react.default.useMemo(function () {\n    return function () {\n      stopInterception();\n      (0, _router.navigate)(interceptedPath);\n    };\n  }, [stopInterception, interceptedPath]);\n\n  var resetPath = _react.default.useMemo(function () {\n    return function () {\n      return setInterceptedPath(null);\n    };\n  }, [setInterceptedPath]);\n\n  return [interceptedPath, confirmNavigation, resetPath, stopInterception];\n};\n\nexports.useControlledInterceptor = useControlledInterceptor;","map":{"version":3,"sources":["../src/controlledInterceptor.js"],"names":["useControlledInterceptor","interceptedPath","setInterceptedPath","React","interceptorFunction","stopInterception","confirmNavigation","resetPath"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;AAUO,IAAMA,wBAAwB,GAAG,SAA3BA,wBAA2B,GAAM;AAAA,MAAA,eAAA,GACCG,MAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CADD,IACCA,CADD;AAAA,MAAA,gBAAA,GAAA,cAAA,CAAA,eAAA,EAAA,CAAA,CAAA;AAAA,MACtCF,eADsC,GAAA,gBAAA,CAAA,CAAA,CAAA;AAAA,MACrBC,kBADqB,GAAA,gBAAA,CAAA,CAAA,CAAA;;AAG7C,MAAME,mBAAmB,GAAG,MAAA,CAAA,OAAA,CAAA,OAAA,CAC3B,YAAA;AAAA,WAAM,UAAA,WAAA,EAAA,QAAA,EAA2B;AAChCF,MAAAA,kBAAkB,CAAlBA,QAAkB,CAAlBA;AACA,aAAA,WAAA;AAFD,KAAA;AAD2B,GAAA,EAK3B,CALD,kBAKC,CAL2B,CAA5B;;AAQA,MAAMG,gBAAgB,GAAG,CAAA,GAAA,YAAA,CAAA,cAAA,EAAzB,mBAAyB,CAAzB;;AAEA,MAAMC,iBAAiB,GAAG,MAAA,CAAA,OAAA,CAAA,OAAA,CACzB,YAAA;AAAA,WAAM,YAAM;AACXD,MAAAA,gBAAgB;AAChB,OAAA,GAAA,OAAA,CAAA,QAAA,EAAA,eAAA;AAFD,KAAA;AADyB,GAAA,EAKzB,CAAA,gBAAA,EALD,eAKC,CALyB,CAA1B;;AAQA,MAAME,SAAS,GAAG,MAAA,CAAA,OAAA,CAAA,OAAA,CACjB,YAAA;AAAA,WAAM,YAAA;AAAA,aAAML,kBAAkB,CAAxB,IAAwB,CAAxB;AAAN,KAAA;AADiB,GAAA,EAEjB,CAFD,kBAEC,CAFiB,CAAlB;;AAKA,SAAO,CAAA,eAAA,EAAA,iBAAA,EAAA,SAAA,EAAP,gBAAO,CAAP;AA1BM,CAAA","sourcesContent":["import React from 'react';\r\nimport {useInterceptor} from \"./interceptor\";\r\nimport {navigate} from \"./router\";\r\n\r\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\r\nexport const useControlledInterceptor = () => {\r\n\tconst [interceptedPath, setInterceptedPath] = React.useState(null);\r\n\r\n\tconst interceptorFunction = React.useMemo(\r\n\t\t() => (currentPath, nextPath) => {\r\n\t\t\tsetInterceptedPath(nextPath);\r\n\t\t\treturn currentPath;\r\n\t\t},\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\tconst stopInterception = useInterceptor(interceptorFunction);\r\n\r\n\tconst confirmNavigation = React.useMemo(\r\n\t\t() => () => {\r\n\t\t\tstopInterception();\r\n\t\t\tnavigate(interceptedPath);\r\n\t\t},\r\n\t\t[stopInterception, interceptedPath]\r\n\t);\r\n\r\n\tconst resetPath = React.useMemo(\r\n\t\t() => () => setInterceptedPath(null),\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\treturn [interceptedPath, confirmNavigation, resetPath, stopInterception];\r\n};\r\n"]},"metadata":{},"sourceType":"script"}